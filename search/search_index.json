{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PSFMachine PRF photometry with Kepler PSFMachine is an open source Python tool for creating models of instrument effective Point Spread Functions (ePSFs), a.k.a Pixel Response Functions (PRFs). These models are then used to fit a scene in a stack of astronomical images. PSFMachine is able to quickly derive photometry from stacks of Kepler images and separate crowded sources. Installation pip install psfmachine What's happening? PSFMachine is doing a few things for you, it's using the Gaia archive to find all the sources in your images building a Pixel Response Function (PRF) model based on all the sources fitting the PRF to all the sources in an image stack, to find the best fitting flux of all sources, accounting for crowding and contamination returning neat, lightkurve.LightCurve objects of all the sources in the images, with all the available meta data. What does it look like? After you run PSFmachine on a stack of images you can retrieve data like this. Here is an example of a very crowded Kepler Object of Interest KOI-608. This object looks like a planet transit, but there are actually two targets almost exactly overlapping each other! You can see this on the right hand side, where an image of the target is shown with the two stars identified by Gaia highlighted. The output of PSFMachine is on the right hand side, and shows two light curves, one for each source. PSFMachine has separated the light curves of these sources, despite the fact that they are separated by less than a pixel, and the background source is over 2 magnitudes fainter. We can flatten and fold these light curves at the transit period to find the following In black we see the original Kepler light curve, which looks like an exoplanet transit. When using PSFMachine to split these two sources, we see that the transit is actually around the orange target (which is fainter), and has been significantly diluted. PSFMachine is able to separate these sources with high confidence, and rule out the blue source as the origin of the transit. What can I use it on? Currently PSFMachine is designed to work with Kepler data. The tool should work with K2 or TESS data, but some of our key assumptions may break, and so mileage may vary. More work will be done on PSFMachine in the future to better integrate these datasets. If you'd like to try using PSFMachine on a more generic dataset, you can try the Machine class instead of the TPFMachine class to work with more generic data. Example use Below is an example script that shows how to use PSFMachine . Depending on the speed or your computer fitting this sort of model will probably take ~10 minutes to build 200 light curves. You can speed this up by changing some of the input parameters. import psfmachine as psf import lightkurve as lk tpfs = lk.search_targetpixelfile('Kepler-16', mission='Kepler', quarter=12, radius=1000, limit=200, cadence='long').download_all(quality_bitmask=None) machine = psf.TPFMachine.from_TPFs(tpfs, n_r_knots=10, n_phi_knots=12) machine.fit_lightcurves() Funding for this project is provided by NASA ROSES grant number 80NSSC20K0874.","title":"Home"},{"location":"#psfmachine","text":"PRF photometry with Kepler PSFMachine is an open source Python tool for creating models of instrument effective Point Spread Functions (ePSFs), a.k.a Pixel Response Functions (PRFs). These models are then used to fit a scene in a stack of astronomical images. PSFMachine is able to quickly derive photometry from stacks of Kepler images and separate crowded sources.","title":"PSFMachine"},{"location":"#installation","text":"pip install psfmachine","title":"Installation"},{"location":"#whats-happening","text":"PSFMachine is doing a few things for you, it's using the Gaia archive to find all the sources in your images building a Pixel Response Function (PRF) model based on all the sources fitting the PRF to all the sources in an image stack, to find the best fitting flux of all sources, accounting for crowding and contamination returning neat, lightkurve.LightCurve objects of all the sources in the images, with all the available meta data.","title":"What's happening?"},{"location":"#what-does-it-look-like","text":"After you run PSFmachine on a stack of images you can retrieve data like this. Here is an example of a very crowded Kepler Object of Interest KOI-608. This object looks like a planet transit, but there are actually two targets almost exactly overlapping each other! You can see this on the right hand side, where an image of the target is shown with the two stars identified by Gaia highlighted. The output of PSFMachine is on the right hand side, and shows two light curves, one for each source. PSFMachine has separated the light curves of these sources, despite the fact that they are separated by less than a pixel, and the background source is over 2 magnitudes fainter. We can flatten and fold these light curves at the transit period to find the following In black we see the original Kepler light curve, which looks like an exoplanet transit. When using PSFMachine to split these two sources, we see that the transit is actually around the orange target (which is fainter), and has been significantly diluted. PSFMachine is able to separate these sources with high confidence, and rule out the blue source as the origin of the transit.","title":"What does it look like?"},{"location":"#what-can-i-use-it-on","text":"Currently PSFMachine is designed to work with Kepler data. The tool should work with K2 or TESS data, but some of our key assumptions may break, and so mileage may vary. More work will be done on PSFMachine in the future to better integrate these datasets. If you'd like to try using PSFMachine on a more generic dataset, you can try the Machine class instead of the TPFMachine class to work with more generic data.","title":"What can I use it on?"},{"location":"#example-use","text":"Below is an example script that shows how to use PSFMachine . Depending on the speed or your computer fitting this sort of model will probably take ~10 minutes to build 200 light curves. You can speed this up by changing some of the input parameters. import psfmachine as psf import lightkurve as lk tpfs = lk.search_targetpixelfile('Kepler-16', mission='Kepler', quarter=12, radius=1000, limit=200, cadence='long').download_all(quality_bitmask=None) machine = psf.TPFMachine.from_TPFs(tpfs, n_r_knots=10, n_phi_knots=12) machine.fit_lightcurves() Funding for this project is provided by NASA ROSES grant number 80NSSC20K0874.","title":"Example use"},{"location":"machine/","text":"Documentation for Machine Class for calculating fast PRF photometry on a collection of images and a list of in image sources. This method is discussed in detail in CITATION This method solves a linear model to assuming Gaussian priors on the weight of each linear components as explained by Luger, Foreman-Mackey & Hogg, 2017 (https://ui.adsabs.harvard.edu/abs/2017RNAAS...1....7L/abstract) __init__ ( self , time , flux , flux_err , ra , dec , sources , column , row , limit_radius = 24.0 , time_mask = None , n_r_knots = 10 , n_phi_knots = 15 , n_time_knots = 10 , n_time_points = 200 , time_radius = 8 , rmin = 1 , rmax = 16 ) special Class for calculating fast PRF photometry on a collection of images and a list of in image sources. This method is discussed in detail in CITATION This method solves a linear model to assuming Gaussian priors on the weight of each linear components as explained by Luger, Foreman-Mackey & Hogg, 2017 (https://ui.adsabs.harvard.edu/abs/2017RNAAS...1....7L/abstract) Parameters: Name Type Description Default time numpy.ndarray Time values in JD required flux numpy.ndarray Flux values at each pixels and times in units of electrons / sec required flux_err numpy.ndarray Flux error values at each pixels and times in units of electrons / sec required ra numpy.ndarray Right Ascension coordinate of each pixel required dec numpy.ndarray Declination coordinate of each pixel required sources pandas.DataFrame DataFrame with source present in the images required column np.ndarray Data array containing the \"columns\" of the detector that each pixel is on. required row np.ndarray Data array containing the \"columns\" of the detector that each pixel is on. required limit_radius numpy.ndarray Radius limit in arcsecs to select stars to be used for PRF modeling 24.0 time_mask np.ndarray of booleans A boolean array of shape time. Only values where this mask is True will be used to calculate the average image for fitting the PSF. Use this to e.g. select frames with low VA, or no focus change None n_r_knots int Number of radial knots in the spline model. 10 n_phi_knots int Number of azimuthal knots in the spline model. 15 n_time_points int Number of time points to bin by when fitting for velocity aberration. 200 time_radius float The radius around sources, out to which the velocity aberration model will be fit. (arcseconds) 8 rmin float The minimum radius for the PRF model to be fit. (arcseconds) 1 rmax float The maximum radius for the PRF model to be fit. (arcseconds) 16 Attributes: Name Type Description nsources int Number of sources to be extracted nt int Number of onservations in the time series (aka number of cadences) npixels int Total number of pixels with flux measurements source_flux_estimates numpy.ndarray First estimation of pixel fluxes assuming values given by the sources catalog (e.g. Gaia phot_g_mean_flux) dra numpy.ndarray Distance in right ascension between pixel and source coordinates, units of degrees ddec numpy.ndarray Distance in declination between pixel and source coordinates, units of degrees r numpy.ndarray Radial distance between pixel and source coordinates (polar coordinates), in units of arcseconds phi numpy.ndarray Angle between pixel and source coordinates (polar coordinates), in units of radians source_mask scipy.sparce.csr_matrix Sparce mask matrix with pixels that contains flux from sources uncontaminated_source_mask scipy.sparce.csr_matrix Sparce mask matrix with selected uncontaminated pixels per source to be used to build the PSF model mean_model scipy.sparce.csr_matrix Mean PSF model values per pixel used for PSF photometry build_shape_model ( self , plot = False , flux_cut_off = 1 ) Builds a sparse model matrix of shape nsources x npixels to be used when fitting each source pixels to estimate its PSF photometry Parameters: Name Type Description Default flux_cut_off float the flux in COUNTS at which to stop evaluating the model! 1 fit_model ( self , fit_va = False ) Finds the best fitting weights for every source, simultaneously plot_shape_model ( self , radius = 20 ) Diagnostic plot of shape model...","title":"Machine"},{"location":"machine/#documentation-for-machine","text":"Class for calculating fast PRF photometry on a collection of images and a list of in image sources. This method is discussed in detail in CITATION This method solves a linear model to assuming Gaussian priors on the weight of each linear components as explained by Luger, Foreman-Mackey & Hogg, 2017 (https://ui.adsabs.harvard.edu/abs/2017RNAAS...1....7L/abstract)","title":"Documentation for Machine"},{"location":"machine/#psfmachine.machine.Machine.__init__","text":"Class for calculating fast PRF photometry on a collection of images and a list of in image sources. This method is discussed in detail in CITATION This method solves a linear model to assuming Gaussian priors on the weight of each linear components as explained by Luger, Foreman-Mackey & Hogg, 2017 (https://ui.adsabs.harvard.edu/abs/2017RNAAS...1....7L/abstract) Parameters: Name Type Description Default time numpy.ndarray Time values in JD required flux numpy.ndarray Flux values at each pixels and times in units of electrons / sec required flux_err numpy.ndarray Flux error values at each pixels and times in units of electrons / sec required ra numpy.ndarray Right Ascension coordinate of each pixel required dec numpy.ndarray Declination coordinate of each pixel required sources pandas.DataFrame DataFrame with source present in the images required column np.ndarray Data array containing the \"columns\" of the detector that each pixel is on. required row np.ndarray Data array containing the \"columns\" of the detector that each pixel is on. required limit_radius numpy.ndarray Radius limit in arcsecs to select stars to be used for PRF modeling 24.0 time_mask np.ndarray of booleans A boolean array of shape time. Only values where this mask is True will be used to calculate the average image for fitting the PSF. Use this to e.g. select frames with low VA, or no focus change None n_r_knots int Number of radial knots in the spline model. 10 n_phi_knots int Number of azimuthal knots in the spline model. 15 n_time_points int Number of time points to bin by when fitting for velocity aberration. 200 time_radius float The radius around sources, out to which the velocity aberration model will be fit. (arcseconds) 8 rmin float The minimum radius for the PRF model to be fit. (arcseconds) 1 rmax float The maximum radius for the PRF model to be fit. (arcseconds) 16 Attributes: Name Type Description nsources int Number of sources to be extracted nt int Number of onservations in the time series (aka number of cadences) npixels int Total number of pixels with flux measurements source_flux_estimates numpy.ndarray First estimation of pixel fluxes assuming values given by the sources catalog (e.g. Gaia phot_g_mean_flux) dra numpy.ndarray Distance in right ascension between pixel and source coordinates, units of degrees ddec numpy.ndarray Distance in declination between pixel and source coordinates, units of degrees r numpy.ndarray Radial distance between pixel and source coordinates (polar coordinates), in units of arcseconds phi numpy.ndarray Angle between pixel and source coordinates (polar coordinates), in units of radians source_mask scipy.sparce.csr_matrix Sparce mask matrix with pixels that contains flux from sources uncontaminated_source_mask scipy.sparce.csr_matrix Sparce mask matrix with selected uncontaminated pixels per source to be used to build the PSF model mean_model scipy.sparce.csr_matrix Mean PSF model values per pixel used for PSF photometry","title":"__init__()"},{"location":"machine/#psfmachine.machine.Machine.build_shape_model","text":"Builds a sparse model matrix of shape nsources x npixels to be used when fitting each source pixels to estimate its PSF photometry Parameters: Name Type Description Default flux_cut_off float the flux in COUNTS at which to stop evaluating the model! 1","title":"build_shape_model()"},{"location":"machine/#psfmachine.machine.Machine.fit_model","text":"Finds the best fitting weights for every source, simultaneously","title":"fit_model()"},{"location":"machine/#psfmachine.machine.Machine.plot_shape_model","text":"Diagnostic plot of shape model...","title":"plot_shape_model()"},{"location":"tpf/","text":"Documentation for TPFMachine Subclass of Machine that specifically works with TPFs fit_lightcurves ( self , plot = False , fit_va = True , iter_negative = True ) Fit the sources inside the TPFs passed to TPFMachine . Parameters: Name Type Description Default plot bool Whether or not to show some diagnostic plots. These can be helpful for a user to see if the PRF and time dependent models are being calculated correctly. False fit_va bool Whether or not to fit Velocity Aberration (which implicitly will try to fit other kinds of time variability). This will try to fit the \"long term\" trends in the dataset. If True, this will take slightly longer to fit. If you are interested in short term phenomena, like transits, you may find you do not need this to be set to True. If you have the time, it is recommended to run it. True iter_negative bool When fitting light curves, it isn't possible to force the flux to be positive. As such, when we find there are light curves that deviate into negative flux values, we can clip these targets out of the analysis and rerun the model. If iter_negative is True, PSFmachine will run up to 3 times, clipping out any negative targets each round. True from_TPFs ( tpfs , magnitude_limit = 18 , dr = 2 , time_mask = None , query_ra = None , query_dec = None , query_rad = None , ** kwargs ) staticmethod Convert TPF input into Machine object: Parse TPFs to extract time, flux, clux erros, and bookkeeping of the TPF-pixel correspondance Convert pixel-based coordinates (row, column) into WCS (ra, dec) for all pixels Clean pixels with no values, bad cadences, and remove duplicated pixels due to overlapping TPFs Query Gaia DR2 data base to find all sources present in the TPF images Clean unresolve sources (within 6`` = 1.5 pixels) and sources off silicon with a 1 pixel tolerance (distance from source gaia pocition and TPF edge) Parameters: Name Type Description Default tpfs lightkurve TargetPixelFileCollection Collection of Target Pixel files required Returns: Type Description Machine object A Machine class object built from TPFs. lcs_in_tpf ( self , tpf_number ) Returns the light curves from a given TPF as a lightkurve.LightCurveCollection. Parameters: Name Type Description Default tpf_number int Index of the TPF required plot_tpf ( self , tdx ) Make a diagnostic plot of a given TPF in the stack If you passed a stack of TPFs, this function will show an image of that TPF, and all the light curves inside it, alongside a diagnostic of which source the light curve belongs to. Parameters: Name Type Description Default tdx int Index of the TPF to plot required to_fits () Save all the light curves to fits files... rendering: show_root_heading: false show_source: false","title":"TPFMachine"},{"location":"tpf/#documentation-for-tpfmachine","text":"Subclass of Machine that specifically works with TPFs","title":"Documentation for TPFMachine"},{"location":"tpf/#psfmachine.tpf.TPFMachine.fit_lightcurves","text":"Fit the sources inside the TPFs passed to TPFMachine . Parameters: Name Type Description Default plot bool Whether or not to show some diagnostic plots. These can be helpful for a user to see if the PRF and time dependent models are being calculated correctly. False fit_va bool Whether or not to fit Velocity Aberration (which implicitly will try to fit other kinds of time variability). This will try to fit the \"long term\" trends in the dataset. If True, this will take slightly longer to fit. If you are interested in short term phenomena, like transits, you may find you do not need this to be set to True. If you have the time, it is recommended to run it. True iter_negative bool When fitting light curves, it isn't possible to force the flux to be positive. As such, when we find there are light curves that deviate into negative flux values, we can clip these targets out of the analysis and rerun the model. If iter_negative is True, PSFmachine will run up to 3 times, clipping out any negative targets each round. True","title":"fit_lightcurves()"},{"location":"tpf/#psfmachine.tpf.TPFMachine.from_TPFs","text":"Convert TPF input into Machine object: Parse TPFs to extract time, flux, clux erros, and bookkeeping of the TPF-pixel correspondance Convert pixel-based coordinates (row, column) into WCS (ra, dec) for all pixels Clean pixels with no values, bad cadences, and remove duplicated pixels due to overlapping TPFs Query Gaia DR2 data base to find all sources present in the TPF images Clean unresolve sources (within 6`` = 1.5 pixels) and sources off silicon with a 1 pixel tolerance (distance from source gaia pocition and TPF edge) Parameters: Name Type Description Default tpfs lightkurve TargetPixelFileCollection Collection of Target Pixel files required Returns: Type Description Machine object A Machine class object built from TPFs.","title":"from_TPFs()"},{"location":"tpf/#psfmachine.tpf.TPFMachine.lcs_in_tpf","text":"Returns the light curves from a given TPF as a lightkurve.LightCurveCollection. Parameters: Name Type Description Default tpf_number int Index of the TPF required","title":"lcs_in_tpf()"},{"location":"tpf/#psfmachine.tpf.TPFMachine.plot_tpf","text":"Make a diagnostic plot of a given TPF in the stack If you passed a stack of TPFs, this function will show an image of that TPF, and all the light curves inside it, alongside a diagnostic of which source the light curve belongs to. Parameters: Name Type Description Default tdx int Index of the TPF to plot required","title":"plot_tpf()"},{"location":"tpf/#psfmachine.tpf.TPFMachine.to_fits","text":"Save all the light curves to fits files... rendering: show_root_heading: false show_source: false","title":"to_fits()"}]}