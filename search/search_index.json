{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PSFMachine PRF photometry with Kepler PSFMachine is an open source Python tool for creating models of instrument effective Point Spread Functions (ePSFs), a.k.a Pixel Response Functions (PRFs). These models are then used to fit a scene in a stack of astronomical images. PSFMachine is able to quickly derive photometry from stacks of Kepler images and separate crowded sources. Installation pip install psfmachine What's happening? PSFMachine is doing a few things for you, it's using the Gaia archive to find all the sources in your images building a Pixel Response Function (PRF) model based on all the sources fitting the PRF to all the sources in an image stack, to find the best fitting flux of all sources, accounting for crowding and contamination creating custom apertures masks that follow the PRF profile to performed aperture photometry returning neat, lightkurve.LightCurve objects of all the sources in the images, with all the available meta data. What does it look like? After you run PSFmachine on a stack of images you can retrieve data like this. Here is an example of a very crowded Kepler Object of Interest KOI-608. This object looks like a planet transit, but there are actually two targets almost exactly overlapping each other! You can see this on the right hand side, where an image of the target is shown with the two stars identified by Gaia highlighted. The output of PSFMachine is on the right hand side, and shows two light curves, one for each source. PSFMachine has separated the light curves of these sources, despite the fact that they are separated by less than a pixel, and the background source is over 2 magnitudes fainter. We can flatten and fold these light curves at the transit period to find the following In black we see the original Kepler light curve, which looks like an exoplanet transit. When using PSFMachine to split these two sources, we see that the transit is actually around the orange target (which is fainter), and has been significantly diluted. PSFMachine is able to separate these sources with high confidence, and rule out the blue source as the origin of the transit. What can I use it on? Currently PSFMachine is designed to work with Kepler data. The tool should work with K2 or TESS data, but some of our key assumptions may break, and so mileage may vary. More work will be done on PSFMachine in the future to better integrate these datasets. If you'd like to try using PSFMachine on a more generic dataset, you can try the Machine class instead of the TPFMachine class to work with more generic data. Example use Below is an example script that shows how to use PSFMachine . Depending on the speed or your computer fitting this sort of model will probably take ~10 minutes to build 200 light curves. You can speed this up by changing some of the input parameters. import psfmachine as psf import lightkurve as lk tpfs = lk.search_targetpixelfile('Kepler-16', mission='Kepler', quarter=12, radius=1000, limit=200, cadence='long').download_all(quality_bitmask=None) machine = psf.TPFMachine.from_TPFs(tpfs, n_r_knots=10, n_phi_knots=12) machine.fit_lightcurves() Funding for this project is provided by NASA ROSES grant number 80NSSC20K0874.","title":"Home"},{"location":"#psfmachine","text":"PRF photometry with Kepler PSFMachine is an open source Python tool for creating models of instrument effective Point Spread Functions (ePSFs), a.k.a Pixel Response Functions (PRFs). These models are then used to fit a scene in a stack of astronomical images. PSFMachine is able to quickly derive photometry from stacks of Kepler images and separate crowded sources.","title":"PSFMachine"},{"location":"#installation","text":"pip install psfmachine","title":"Installation"},{"location":"#whats-happening","text":"PSFMachine is doing a few things for you, it's using the Gaia archive to find all the sources in your images building a Pixel Response Function (PRF) model based on all the sources fitting the PRF to all the sources in an image stack, to find the best fitting flux of all sources, accounting for crowding and contamination creating custom apertures masks that follow the PRF profile to performed aperture photometry returning neat, lightkurve.LightCurve objects of all the sources in the images, with all the available meta data.","title":"What's happening?"},{"location":"#what-does-it-look-like","text":"After you run PSFmachine on a stack of images you can retrieve data like this. Here is an example of a very crowded Kepler Object of Interest KOI-608. This object looks like a planet transit, but there are actually two targets almost exactly overlapping each other! You can see this on the right hand side, where an image of the target is shown with the two stars identified by Gaia highlighted. The output of PSFMachine is on the right hand side, and shows two light curves, one for each source. PSFMachine has separated the light curves of these sources, despite the fact that they are separated by less than a pixel, and the background source is over 2 magnitudes fainter. We can flatten and fold these light curves at the transit period to find the following In black we see the original Kepler light curve, which looks like an exoplanet transit. When using PSFMachine to split these two sources, we see that the transit is actually around the orange target (which is fainter), and has been significantly diluted. PSFMachine is able to separate these sources with high confidence, and rule out the blue source as the origin of the transit.","title":"What does it look like?"},{"location":"#what-can-i-use-it-on","text":"Currently PSFMachine is designed to work with Kepler data. The tool should work with K2 or TESS data, but some of our key assumptions may break, and so mileage may vary. More work will be done on PSFMachine in the future to better integrate these datasets. If you'd like to try using PSFMachine on a more generic dataset, you can try the Machine class instead of the TPFMachine class to work with more generic data.","title":"What can I use it on?"},{"location":"#example-use","text":"Below is an example script that shows how to use PSFMachine . Depending on the speed or your computer fitting this sort of model will probably take ~10 minutes to build 200 light curves. You can speed this up by changing some of the input parameters. import psfmachine as psf import lightkurve as lk tpfs = lk.search_targetpixelfile('Kepler-16', mission='Kepler', quarter=12, radius=1000, limit=200, cadence='long').download_all(quality_bitmask=None) machine = psf.TPFMachine.from_TPFs(tpfs, n_r_knots=10, n_phi_knots=12) machine.fit_lightcurves() Funding for this project is provided by NASA ROSES grant number 80NSSC20K0874.","title":"Example use"},{"location":"aperture/","text":"Documentation for Aperture Collection of aperture utils lifted from Kepler-Apertures and adapted to work with PSFMachine. Some this functions inputs and operate on a Machine object but we move them out of mahine.py to keep the latter smowhow clean and short. compute_CROWDSAP ( psf_models , aperture_mask , idx = None ) Compute the ratio of target flux relative to flux from all sources within the photometric aperture (i.e. 1 - Crowdeness). Follows definition by Kinemuchi at al. 2012. Parameters: Name Type Description Default psf_models scipy.sparce.csr_matrix Sparse matrix with the PSF models for all targets in the scene. It has shape [n_sources, n_pixels]. required aperture_mask numpy.ndarray Array of boolean indicating the aperture for the target source. It has shape of [n_sources, n_pixels]. required idx int Source index for what the metric is computed. Value has to be betweeen 0 and psf_model first dimension size. If None, it returns the metric for all sources (first dimension of psf_model). None Returns: Type Description numpy.ndarray Crowdeness metric compute_FLFRCSAP ( psf_models , aperture_mask ) Compute fraction of target flux enclosed in the optimal aperture to total flux for a given source (flux completeness). Follows definition by Kinemuchi at al. 2012. Parameters: Name Type Description Default psf_models scipy.sparce.csr_matrix Sparse matrix with the PSF models for all targets in the scene. It has shape [n_sources, n_pixels]. required aperture_mask numpy.ndarray Array of boolean indicating the aperture for the target source. It has shape of [n_sources, n_pixels]. required Returns: Type Description numpy.ndarray Completeness metric estimate_source_centroids_aperture ( aperture_mask , flux , column , row ) Computes the centroid via 2D moments methods for all sources all times. It needs aperture_mask to be computed first by runing compute_aperture_photometry . Parameters: Name Type Description Default aperture_mask numpy.ndarray Aperture mask, shape is [n_surces, n_pixels] required flux numpy.ndarray Flux values at each pixels and times in units of electrons / sec required column numpy.ndarray Data array containing the \"columns\" of the detector that each pixel is on. required row numpy.ndarray Data array containing the \"rows\" of the detector that each pixel is on. required Returns: Type Description numpy.ndarray Column pixel number of the moments centroid, shape is [nsources, ntimes]. goodness_metric_obj_fun ( percentile , optim_params ) The objective function to minimize with scipy.optimize.minimize_scalar called during optimization of the photometric aperture. Parameters: Name Type Description Default percentile int Percentile of the normalized flux distribution that defines the isophote. required optim_params dictionary Dictionary with the variables needed to evaluate the metric: * psf_models * sdx * target_complete * target_crowd required Returns: Type Description float Value of the objective function to be used for optiization. optimize_aperture ( psf_model , target_complete = 0.9 , target_crowd = 0.9 , max_iter = 100 , percentile_bounds = [ 0 , 100 ], quiet = False ) Function to optimize the aperture mask for a given source. The optimization is done using scipy Brent's algorithm and it uses a custom loss function goodness_metric_obj_fun that uses a Leaky ReLU term to achive the target value for both metrics. Parameters: Name Type Description Default psf_model scipy.sparce.csr_matrix Sparse matrix with the PSF models for all targets in the scene. It has shape [n_sources, n_pixels]. required target_complete float Value of the target completeness metric. 0.9 target_crowd float Value of the target crowdeness metric. 0.9 max_iter int Numer of maximum iterations to be performed by the optimizer. 100 percentile_bounds tuple Tuple of minimun and maximun values for allowed percentile values during the optimization. Default is the widest range of [0, 100]. [0, 100] Returns: Type Description numpy.ndarray An array with the percentile value to defines the \"optimal\" aperture for each source. plot_flux_metric_diagnose ( psf_model , idx = 0 , ax = None , optimal_percentile = None ) Function to evaluate the flux metrics for a single source as a function of the parameter that controls the aperture size. The flux metrics are computed by taking into account the PSF models of neighbor sources. This function is meant to be used only to generate diagnostic figures. Parameters: Name Type Description Default psf_model scipy.sparce.csr_matrix Sparse matrix with the PSF models for all targets in the scene. It has shape [n_sources, n_pixels]. required idx int Index of the source for which the metrcs will be computed. Has to be a number between 0 and psf_models.shape[0]. 0 ax matplotlib.axes Axis to be used to plot the figure None Returns: Type Description matplotlib.axes Figure axes","title":"Aperture Photometry"},{"location":"aperture/#documentation-for-aperture","text":"Collection of aperture utils lifted from Kepler-Apertures and adapted to work with PSFMachine. Some this functions inputs and operate on a Machine object but we move them out of mahine.py to keep the latter smowhow clean and short.","title":"Documentation for Aperture"},{"location":"aperture/#psfmachine.aperture.compute_CROWDSAP","text":"Compute the ratio of target flux relative to flux from all sources within the photometric aperture (i.e. 1 - Crowdeness). Follows definition by Kinemuchi at al. 2012. Parameters: Name Type Description Default psf_models scipy.sparce.csr_matrix Sparse matrix with the PSF models for all targets in the scene. It has shape [n_sources, n_pixels]. required aperture_mask numpy.ndarray Array of boolean indicating the aperture for the target source. It has shape of [n_sources, n_pixels]. required idx int Source index for what the metric is computed. Value has to be betweeen 0 and psf_model first dimension size. If None, it returns the metric for all sources (first dimension of psf_model). None Returns: Type Description numpy.ndarray Crowdeness metric","title":"compute_CROWDSAP()"},{"location":"aperture/#psfmachine.aperture.compute_FLFRCSAP","text":"Compute fraction of target flux enclosed in the optimal aperture to total flux for a given source (flux completeness). Follows definition by Kinemuchi at al. 2012. Parameters: Name Type Description Default psf_models scipy.sparce.csr_matrix Sparse matrix with the PSF models for all targets in the scene. It has shape [n_sources, n_pixels]. required aperture_mask numpy.ndarray Array of boolean indicating the aperture for the target source. It has shape of [n_sources, n_pixels]. required Returns: Type Description numpy.ndarray Completeness metric","title":"compute_FLFRCSAP()"},{"location":"aperture/#psfmachine.aperture.estimate_source_centroids_aperture","text":"Computes the centroid via 2D moments methods for all sources all times. It needs aperture_mask to be computed first by runing compute_aperture_photometry . Parameters: Name Type Description Default aperture_mask numpy.ndarray Aperture mask, shape is [n_surces, n_pixels] required flux numpy.ndarray Flux values at each pixels and times in units of electrons / sec required column numpy.ndarray Data array containing the \"columns\" of the detector that each pixel is on. required row numpy.ndarray Data array containing the \"rows\" of the detector that each pixel is on. required Returns: Type Description numpy.ndarray Column pixel number of the moments centroid, shape is [nsources, ntimes].","title":"estimate_source_centroids_aperture()"},{"location":"aperture/#psfmachine.aperture.goodness_metric_obj_fun","text":"The objective function to minimize with scipy.optimize.minimize_scalar called during optimization of the photometric aperture. Parameters: Name Type Description Default percentile int Percentile of the normalized flux distribution that defines the isophote. required optim_params dictionary Dictionary with the variables needed to evaluate the metric: * psf_models * sdx * target_complete * target_crowd required Returns: Type Description float Value of the objective function to be used for optiization.","title":"goodness_metric_obj_fun()"},{"location":"aperture/#psfmachine.aperture.optimize_aperture","text":"Function to optimize the aperture mask for a given source. The optimization is done using scipy Brent's algorithm and it uses a custom loss function goodness_metric_obj_fun that uses a Leaky ReLU term to achive the target value for both metrics. Parameters: Name Type Description Default psf_model scipy.sparce.csr_matrix Sparse matrix with the PSF models for all targets in the scene. It has shape [n_sources, n_pixels]. required target_complete float Value of the target completeness metric. 0.9 target_crowd float Value of the target crowdeness metric. 0.9 max_iter int Numer of maximum iterations to be performed by the optimizer. 100 percentile_bounds tuple Tuple of minimun and maximun values for allowed percentile values during the optimization. Default is the widest range of [0, 100]. [0, 100] Returns: Type Description numpy.ndarray An array with the percentile value to defines the \"optimal\" aperture for each source.","title":"optimize_aperture()"},{"location":"aperture/#psfmachine.aperture.plot_flux_metric_diagnose","text":"Function to evaluate the flux metrics for a single source as a function of the parameter that controls the aperture size. The flux metrics are computed by taking into account the PSF models of neighbor sources. This function is meant to be used only to generate diagnostic figures. Parameters: Name Type Description Default psf_model scipy.sparce.csr_matrix Sparse matrix with the PSF models for all targets in the scene. It has shape [n_sources, n_pixels]. required idx int Index of the source for which the metrcs will be computed. Has to be a number between 0 and psf_models.shape[0]. 0 ax matplotlib.axes Axis to be used to plot the figure None Returns: Type Description matplotlib.axes Figure axes","title":"plot_flux_metric_diagnose()"},{"location":"ffi/","text":"Documentation for FFIMachine Subclass of Machine for working with FFI data. It is a subclass of Machine __init__ ( self , time , flux , flux_err , ra , dec , sources , column , row , wcs = None , limit_radius = 32.0 , n_r_knots = 10 , n_phi_knots = 15 , n_time_knots = 10 , n_time_points = 200 , time_radius = 8 , cut_r = 6 , rmin = 1 , rmax = 16 , meta = None ) special Parameters: Name Type Description Default time numpy.ndarray Time values in JD required flux numpy.ndarray Flux values at each pixels and times in units of electrons / sec. Has shape [n_times, n_rows, n_columns] required flux_err numpy.ndarray Flux error values at each pixels and times in units of electrons / sec. Has shape [n_times, n_rows, n_columns] required ra numpy.ndarray Right Ascension coordinate of each pixel required dec numpy.ndarray Declination coordinate of each pixel required sources pandas.DataFrame DataFrame with source present in the images required column np.ndarray Data array containing the \"columns\" of the detector that each pixel is on. required row np.ndarray Data array containing the \"columns\" of the detector that each pixel is on. required wcs astropy.wcs World coordinates system solution for the FFI. Used for plotting. None meta dictionary Meta data information related to the FFI None Attributes: Name Type Description meta dictionary Meta data information related to the FFI wcs astropy.wcs World coordinates system solution for the FFI. Used for plotting. flux_2d numpy.ndarray 2D image representation of the FFI, used for plotting. Has shape [n_times, image_height, image_width] image_shape tuple Shape of 2D image from_file ( fname , extension = 1 , cutout_size = None , cutout_origin = [ 0 , 0 ], correct_offsets = False , plot_offsets = False , ** kwargs ) staticmethod Reads data from files and initiates a new object of FFIMachine class. Parameters: Name Type Description Default fname str or list of strings File name or list of file names of the FFI files. required extension int Number of HDU extension to be used, for Kepler FFIs this corresponds to the channel number. For TESS FFIs, it correspond to the HDU extension containing the image data (1). 1 cutout_size int Size of the cutout in pixels, assumed to be squared None cutout_origin tuple of ints Origin pixel coordinates where to start the cut out. Follows matrix indexing [0, 0] correct_offsets boolean Check and correct for coordinate offset due to wrong WCS. It is off by default. False plot_offsets boolean Create diagnostic plot for oordinate offset correction. False **kwargs dictionary Keyword arguments that defines shape model in a machine class object. See psfmachine.Machine for details. {} Returns: Type Description Machine object A Machine class object built from the FFI. load_shape_model ( self , input = None , plot = False ) Loads a PRF model from disk. Parameters: Name Type Description Default input str, None Input file name. If None, one will be generated. None plot boolean Plot the PRF mean model loaded from disk False plot_image ( self , ax = None , sources = False ) Function to plot the Full Frame Image and Gaia sources. Parameters: Name Type Description Default ax matplotlib.axes Matlotlib axis can be provided, if not one will be created and returned. None sources boolean Whether to overplot or not the source catalog. False Returns: Type Description matplotlib.axes Matlotlib axis with the figure. save_flux_values ( self , output = None , format = 'fits' ) Saves the flux values of all sources to a file. For FITS output files a multi- extension file is created with each extension containing a single cadence/frame. Parameters: Name Type Description Default output str, None Output file name. If None, one will be generated. None format str Format of the output file. Only FITS is supported for now. 'fits' save_shape_model ( self , output = None ) Saves the weights of a PRF fit to disk. Parameters: Name Type Description Default output str, None Output file name. If None, one will be generated. None","title":"FFIMachine"},{"location":"ffi/#documentation-for-ffimachine","text":"Subclass of Machine for working with FFI data. It is a subclass of Machine","title":"Documentation for FFIMachine"},{"location":"ffi/#psfmachine.ffi.FFIMachine.__init__","text":"Parameters: Name Type Description Default time numpy.ndarray Time values in JD required flux numpy.ndarray Flux values at each pixels and times in units of electrons / sec. Has shape [n_times, n_rows, n_columns] required flux_err numpy.ndarray Flux error values at each pixels and times in units of electrons / sec. Has shape [n_times, n_rows, n_columns] required ra numpy.ndarray Right Ascension coordinate of each pixel required dec numpy.ndarray Declination coordinate of each pixel required sources pandas.DataFrame DataFrame with source present in the images required column np.ndarray Data array containing the \"columns\" of the detector that each pixel is on. required row np.ndarray Data array containing the \"columns\" of the detector that each pixel is on. required wcs astropy.wcs World coordinates system solution for the FFI. Used for plotting. None meta dictionary Meta data information related to the FFI None Attributes: Name Type Description meta dictionary Meta data information related to the FFI wcs astropy.wcs World coordinates system solution for the FFI. Used for plotting. flux_2d numpy.ndarray 2D image representation of the FFI, used for plotting. Has shape [n_times, image_height, image_width] image_shape tuple Shape of 2D image","title":"__init__()"},{"location":"ffi/#psfmachine.ffi.FFIMachine.from_file","text":"Reads data from files and initiates a new object of FFIMachine class. Parameters: Name Type Description Default fname str or list of strings File name or list of file names of the FFI files. required extension int Number of HDU extension to be used, for Kepler FFIs this corresponds to the channel number. For TESS FFIs, it correspond to the HDU extension containing the image data (1). 1 cutout_size int Size of the cutout in pixels, assumed to be squared None cutout_origin tuple of ints Origin pixel coordinates where to start the cut out. Follows matrix indexing [0, 0] correct_offsets boolean Check and correct for coordinate offset due to wrong WCS. It is off by default. False plot_offsets boolean Create diagnostic plot for oordinate offset correction. False **kwargs dictionary Keyword arguments that defines shape model in a machine class object. See psfmachine.Machine for details. {} Returns: Type Description Machine object A Machine class object built from the FFI.","title":"from_file()"},{"location":"ffi/#psfmachine.ffi.FFIMachine.load_shape_model","text":"Loads a PRF model from disk. Parameters: Name Type Description Default input str, None Input file name. If None, one will be generated. None plot boolean Plot the PRF mean model loaded from disk False","title":"load_shape_model()"},{"location":"ffi/#psfmachine.ffi.FFIMachine.plot_image","text":"Function to plot the Full Frame Image and Gaia sources. Parameters: Name Type Description Default ax matplotlib.axes Matlotlib axis can be provided, if not one will be created and returned. None sources boolean Whether to overplot or not the source catalog. False Returns: Type Description matplotlib.axes Matlotlib axis with the figure.","title":"plot_image()"},{"location":"ffi/#psfmachine.ffi.FFIMachine.save_flux_values","text":"Saves the flux values of all sources to a file. For FITS output files a multi- extension file is created with each extension containing a single cadence/frame. Parameters: Name Type Description Default output str, None Output file name. If None, one will be generated. None format str Format of the output file. Only FITS is supported for now. 'fits'","title":"save_flux_values()"},{"location":"ffi/#psfmachine.ffi.FFIMachine.save_shape_model","text":"Saves the weights of a PRF fit to disk. Parameters: Name Type Description Default output str, None Output file name. If None, one will be generated. None","title":"save_shape_model()"},{"location":"machine/","text":"Documentation for Machine Class for calculating fast PRF photometry on a collection of images and a list of in image sources. This method is discussed in detail in Hedges et al. 2021 . This method solves a linear model to assuming Gaussian priors on the weight of each linear components as explained by Luger, Foreman-Mackey & Hogg, 2017 __init__ ( self , time , flux , flux_err , ra , dec , sources , column , row , limit_radius = 24.0 , time_mask = None , n_r_knots = 10 , n_phi_knots = 15 , n_time_knots = 10 , n_time_points = 200 , time_radius = 8 , rmin = 1 , rmax = 16 , cut_r = 6 , sparse_dist_lim = 40 ) special Parameters: Name Type Description Default time numpy.ndarray Time values in JD required flux numpy.ndarray Flux values at each pixels and times in units of electrons / sec required flux_err numpy.ndarray Flux error values at each pixels and times in units of electrons / sec required ra numpy.ndarray Right Ascension coordinate of each pixel required dec numpy.ndarray Declination coordinate of each pixel required sources pandas.DataFrame DataFrame with source present in the images required column np.ndarray Data array containing the \"columns\" of the detector that each pixel is on. required row np.ndarray Data array containing the \"rows\" of the detector that each pixel is on. required limit_radius numpy.ndarray Radius limit in arcsecs to select stars to be used for PRF modeling 24.0 time_mask np.ndarray of booleans A boolean array of shape time. Only values where this mask is True will be used to calculate the average image for fitting the PSF. Use this to e.g. select frames with low VA, or no focus change None n_r_knots int Number of radial knots in the spline model. 10 n_phi_knots int Number of azimuthal knots in the spline model. 15 n_time_points int Number of time points to bin by when fitting for velocity aberration. 200 time_radius float The radius around sources, out to which the velocity aberration model will be fit. (arcseconds) 8 rmin float The minimum radius for the PRF model to be fit. (arcseconds) 1 rmax float The maximum radius for the PRF model to be fit. (arcseconds) 16 sparse_dist_lim float Radial distance used to include pixels around sources when creating delta arrays (dra, ddec, r, and phi) as sparse matrices for efficiency. Default is 40\" (recommended for kepler). (arcseconds) 40 Attributes: Name Type Description nsources int Number of sources to be extracted nt int Number of onservations in the time series (aka number of cadences) npixels int Total number of pixels with flux measurements source_flux_estimates numpy.ndarray First estimation of pixel fluxes assuming values given by the sources catalog (e.g. Gaia phot_g_mean_flux) dra numpy.ndarray Distance in right ascension between pixel and source coordinates, units of degrees ddec numpy.ndarray Distance in declination between pixel and source coordinates, units of degrees r numpy.ndarray Radial distance between pixel and source coordinates (polar coordinates), in units of arcseconds phi numpy.ndarray Angle between pixel and source coordinates (polar coordinates), in units of radians source_mask scipy.sparce.csr_matrix Sparce mask matrix with pixels that contains flux from sources uncontaminated_source_mask scipy.sparce.csr_matrix Sparce mask matrix with selected uncontaminated pixels per source to be used to build the PSF model mean_model scipy.sparce.csr_matrix Mean PSF model values per pixel used for PSF photometry build_shape_model ( self , plot = False , flux_cut_off = 1 , ** kwargs ) Builds a sparse model matrix of shape nsources x npixels to be used when fitting each source pixels to estimate its PSF photometry Parameters: Name Type Description Default flux_cut_off float the flux in COUNTS at which to stop evaluating the model! 1 **kwargs None Keyword arguments to be passed to _get_source_mask() {} build_time_model ( self , plot = False ) Builds a time model that moves the PRF model to account for the scene movement due to velocity aberration. Parameters: Name Type Description Default plot boolean Plot a diagnostic figure. False **kwargs None Keyword arguments to be passed to _get_source_mask() required compute_aperture_photometry ( self , aperture_size = 'optimal' , target_complete = 0.9 , target_crowd = 0.9 ) Computes aperture photometry for all sources in the scene. The aperture shape follow the PRF profile. Parameters: Name Type Description Default aperture_size string or int Size of the aperture to be used. If \"optimal\" the aperture will be optimized using the flux metric targets. If int between [0, 100], then the boundaries of the aperture are calculated from the normalized flux value of the given ith percentile. 'optimal' target_complete float Target flux completeness metric (FLFRCSAP) used if aperture_size is \"optimal\". 0.9 target_crowd float Target flux crowding metric (CROWDSAP) used if aperture_size is \"optimal\". 0.9 create_aperture_mask ( self , percentile = 50 ) Function to create the aperture mask of a given source for a given aperture size. This function can compute aperutre mask for all sources in the scene. It creates three new attributes: * self.aperture_mask has the aperture mask, shape is [n_surces, n_pixels] * self.FLFRCSAP has the completeness metric, shape is [n_sources] * self.CROWDSAP has the crowdeness metric, shape is [n_sources] Parameters: Name Type Description Default percentile float or list of floats Percentile value that defines the isophote from the distribution of values in the PRF model of the source. If float, then all sources will use the same percentile value. If list, then it has to have lenght that matches self.nsources , then each source has its own percentile value. 50 fit_model ( self , fit_va = False ) Finds the best fitting weights for every source, simultaneously Parameters: Name Type Description Default fit_va boolean Fitting model accounting for velocity aberration. If True , then a time model has to be built previously with build_time_model . False plot_shape_model ( self , radius = 20 ) Diagnostic plot of shape model. Parameters: Name Type Description Default radius float Radius (in arcseconds) limit to be shown in the figure. 20 Returns: Type Description matplotlib.Figure Figure. plot_time_model ( self ) Diagnostic plot of time model. Returns: Type Description matplotlib.Figure Figure.","title":"Machine"},{"location":"machine/#documentation-for-machine","text":"Class for calculating fast PRF photometry on a collection of images and a list of in image sources. This method is discussed in detail in Hedges et al. 2021 . This method solves a linear model to assuming Gaussian priors on the weight of each linear components as explained by Luger, Foreman-Mackey & Hogg, 2017","title":"Documentation for Machine"},{"location":"machine/#psfmachine.machine.Machine.__init__","text":"Parameters: Name Type Description Default time numpy.ndarray Time values in JD required flux numpy.ndarray Flux values at each pixels and times in units of electrons / sec required flux_err numpy.ndarray Flux error values at each pixels and times in units of electrons / sec required ra numpy.ndarray Right Ascension coordinate of each pixel required dec numpy.ndarray Declination coordinate of each pixel required sources pandas.DataFrame DataFrame with source present in the images required column np.ndarray Data array containing the \"columns\" of the detector that each pixel is on. required row np.ndarray Data array containing the \"rows\" of the detector that each pixel is on. required limit_radius numpy.ndarray Radius limit in arcsecs to select stars to be used for PRF modeling 24.0 time_mask np.ndarray of booleans A boolean array of shape time. Only values where this mask is True will be used to calculate the average image for fitting the PSF. Use this to e.g. select frames with low VA, or no focus change None n_r_knots int Number of radial knots in the spline model. 10 n_phi_knots int Number of azimuthal knots in the spline model. 15 n_time_points int Number of time points to bin by when fitting for velocity aberration. 200 time_radius float The radius around sources, out to which the velocity aberration model will be fit. (arcseconds) 8 rmin float The minimum radius for the PRF model to be fit. (arcseconds) 1 rmax float The maximum radius for the PRF model to be fit. (arcseconds) 16 sparse_dist_lim float Radial distance used to include pixels around sources when creating delta arrays (dra, ddec, r, and phi) as sparse matrices for efficiency. Default is 40\" (recommended for kepler). (arcseconds) 40 Attributes: Name Type Description nsources int Number of sources to be extracted nt int Number of onservations in the time series (aka number of cadences) npixels int Total number of pixels with flux measurements source_flux_estimates numpy.ndarray First estimation of pixel fluxes assuming values given by the sources catalog (e.g. Gaia phot_g_mean_flux) dra numpy.ndarray Distance in right ascension between pixel and source coordinates, units of degrees ddec numpy.ndarray Distance in declination between pixel and source coordinates, units of degrees r numpy.ndarray Radial distance between pixel and source coordinates (polar coordinates), in units of arcseconds phi numpy.ndarray Angle between pixel and source coordinates (polar coordinates), in units of radians source_mask scipy.sparce.csr_matrix Sparce mask matrix with pixels that contains flux from sources uncontaminated_source_mask scipy.sparce.csr_matrix Sparce mask matrix with selected uncontaminated pixels per source to be used to build the PSF model mean_model scipy.sparce.csr_matrix Mean PSF model values per pixel used for PSF photometry","title":"__init__()"},{"location":"machine/#psfmachine.machine.Machine.build_shape_model","text":"Builds a sparse model matrix of shape nsources x npixels to be used when fitting each source pixels to estimate its PSF photometry Parameters: Name Type Description Default flux_cut_off float the flux in COUNTS at which to stop evaluating the model! 1 **kwargs None Keyword arguments to be passed to _get_source_mask() {}","title":"build_shape_model()"},{"location":"machine/#psfmachine.machine.Machine.build_time_model","text":"Builds a time model that moves the PRF model to account for the scene movement due to velocity aberration. Parameters: Name Type Description Default plot boolean Plot a diagnostic figure. False **kwargs None Keyword arguments to be passed to _get_source_mask() required","title":"build_time_model()"},{"location":"machine/#psfmachine.machine.Machine.compute_aperture_photometry","text":"Computes aperture photometry for all sources in the scene. The aperture shape follow the PRF profile. Parameters: Name Type Description Default aperture_size string or int Size of the aperture to be used. If \"optimal\" the aperture will be optimized using the flux metric targets. If int between [0, 100], then the boundaries of the aperture are calculated from the normalized flux value of the given ith percentile. 'optimal' target_complete float Target flux completeness metric (FLFRCSAP) used if aperture_size is \"optimal\". 0.9 target_crowd float Target flux crowding metric (CROWDSAP) used if aperture_size is \"optimal\". 0.9","title":"compute_aperture_photometry()"},{"location":"machine/#psfmachine.machine.Machine.create_aperture_mask","text":"Function to create the aperture mask of a given source for a given aperture size. This function can compute aperutre mask for all sources in the scene. It creates three new attributes: * self.aperture_mask has the aperture mask, shape is [n_surces, n_pixels] * self.FLFRCSAP has the completeness metric, shape is [n_sources] * self.CROWDSAP has the crowdeness metric, shape is [n_sources] Parameters: Name Type Description Default percentile float or list of floats Percentile value that defines the isophote from the distribution of values in the PRF model of the source. If float, then all sources will use the same percentile value. If list, then it has to have lenght that matches self.nsources , then each source has its own percentile value. 50","title":"create_aperture_mask()"},{"location":"machine/#psfmachine.machine.Machine.fit_model","text":"Finds the best fitting weights for every source, simultaneously Parameters: Name Type Description Default fit_va boolean Fitting model accounting for velocity aberration. If True , then a time model has to be built previously with build_time_model . False","title":"fit_model()"},{"location":"machine/#psfmachine.machine.Machine.plot_shape_model","text":"Diagnostic plot of shape model. Parameters: Name Type Description Default radius float Radius (in arcseconds) limit to be shown in the figure. 20 Returns: Type Description matplotlib.Figure Figure.","title":"plot_shape_model()"},{"location":"machine/#psfmachine.machine.Machine.plot_time_model","text":"Diagnostic plot of time model. Returns: Type Description matplotlib.Figure Figure.","title":"plot_time_model()"},{"location":"tpf/","text":"Documentation for TPFMachine Subclass of Machine that specifically works with TPFs fit_lightcurves ( self , plot = False , fit_va = True , iter_negative = True , load_shape_model = False , shape_model_file = None , sap = True ) Fit the sources inside the TPFs passed to TPFMachine . This function creates the lcs attribuite that contains a collection of light curves in the form of lightkurve.LightCurveCollection . Each entry in the collection is a lightkurve.KeplerLightCurve object with the different type of photometry (SAP, PSF, and PSF velocity-aberration corrected). Also each lightkurve.KeplerLightCurve object includes its asociated metadata. The photometry can also be accessed independently from the following attribuites that fit_lightcurves create: * ws and werrs have the uncorrected PSF flux and flux errors. * ws_va and werrs_va have the PSF flux and flux errors corrected by velocity aberration. * sap_flux and sap_flux_err have the flux and flux errors computed using aperture mask. Parameters: Name Type Description Default plot bool Whether or not to show some diagnostic plots. These can be helpful for a user to see if the PRF and time dependent models are being calculated correctly. False fit_va bool Whether or not to fit Velocity Aberration (which implicitly will try to fit other kinds of time variability). This will try to fit the \"long term\" trends in the dataset. If True, this will take slightly longer to fit. If you are interested in short term phenomena, like transits, you may find you do not need this to be set to True. If you have the time, it is recommended to run it. True iter_negative bool When fitting light curves, it isn't possible to force the flux to be positive. As such, when we find there are light curves that deviate into negative flux values, we can clip these targets out of the analysis and rerun the model. If iter_negative is True, PSFmachine will run up to 3 times, clipping out any negative targets each round. True load_shape_model bool Load PRF shape model from disk or not. Default models were computed from FFI of the same channel and quarter. False shape_model_file string Path to PRF model file to be passed to load_shape_model(input) . If None, then precomputed models will be download from Zenodo repo. None sap boolean Compute or not Simple Aperture Photometry. See Machine.compute_aperture_photometry() for details. True from_TPFs ( tpfs , magnitude_limit = 18 , dr = 2 , time_mask = None , apply_focus_mask = True , query_ra = None , query_dec = None , query_rad = None , ** kwargs ) staticmethod Convert TPF input into Machine object: Parse TPFs to extract time, flux, clux erros, and bookkeeping of the TPF-pixel correspondance Convert pixel-based coordinates (row, column) into WCS (ra, dec) for all pixels Clean pixels with no values, bad cadences, and remove duplicated pixels due to overlapping TPFs Query Gaia DR2 data base to find all sources present in the TPF images Clean unresolve sources (within 6`` = 1.5 pixels) and sources off silicon with a 1 pixel tolerance (distance from source gaia pocition and TPF edge) Parameters: Name Type Description Default tpfs lightkurve TargetPixelFileCollection Collection of Target Pixel files required magnitude_limit float Limiting magnitude to query Gaia catalog. 18 dr int Gaia data release to be use, default is 2, options are DR2 and EDR3 2 time_mask boolean array Mask to be applied to discard cadences if needed. None apply_focus_mask boolean Mask or not cadances near observation gaps to remove focus change. True query_ra numpy.array Array of RA to query Gaia catalog. Default is None and will use the coordinate centers of each TPF. None query_dec numpy.array Array of Dec to query Gaia catalog. Default is None and will use the coordinate centers of each TPF. None query_rad numpy.array Array of radius to query Gaia catalog. Default is None and will use the coordinate centers of each TPF. None **kwargs None Keyword arguments to be passed to TPFMachine . {} Returns: Type Description Machine object A Machine class object built from TPFs. lcs_in_tpf ( self , tpf_number ) Returns the light curves from a given TPF as a lightkurve.LightCurveCollection. Parameters: Name Type Description Default tpf_number int Index of the TPF required load_shape_model ( self , input = None , plot = False ) Loads a PRF shape model from a FITs file. Not implemented: By default this function will load PRF shapes computed from FFI data (Kepler, K2, or TESS). Parameters: Name Type Description Default input string Name of the file containing the shape parameters and weights. The file has to be FITS format. If None, then previously computed shape model from Kepler's FFI will be download from https://zenodo.org/record/5504503/ and used as default. The file download from Zenodo happens only the first time that shape models of a given mission (e.g. Kepler, K2) are asked. Then, shape models for all channels and quarters will be locally available for future use. The file is stored in psfmachine/src/psfmachine/data/ . None plot boolean Plot or not the mean model. False plot_tpf ( self , tdx , sap = True ) Make a diagnostic plot of a given TPF in the stack If you passed a stack of TPFs, this function will show an image of that TPF, and all the light curves inside it, alongside a diagnostic of which source the light curve belongs to. Parameters: Name Type Description Default tdx int Index of the TPF to plot required sap boolean Overplot the pixel mask used for aperture photometry. True save_shape_model ( self , output = None ) Saves the weights of a PRF fit to disk as a FITS file. Parameters: Name Type Description Default output str, None Output file name. If None, one will be generated. None","title":"TPFMachine"},{"location":"tpf/#documentation-for-tpfmachine","text":"Subclass of Machine that specifically works with TPFs","title":"Documentation for TPFMachine"},{"location":"tpf/#psfmachine.tpf.TPFMachine.fit_lightcurves","text":"Fit the sources inside the TPFs passed to TPFMachine . This function creates the lcs attribuite that contains a collection of light curves in the form of lightkurve.LightCurveCollection . Each entry in the collection is a lightkurve.KeplerLightCurve object with the different type of photometry (SAP, PSF, and PSF velocity-aberration corrected). Also each lightkurve.KeplerLightCurve object includes its asociated metadata. The photometry can also be accessed independently from the following attribuites that fit_lightcurves create: * ws and werrs have the uncorrected PSF flux and flux errors. * ws_va and werrs_va have the PSF flux and flux errors corrected by velocity aberration. * sap_flux and sap_flux_err have the flux and flux errors computed using aperture mask. Parameters: Name Type Description Default plot bool Whether or not to show some diagnostic plots. These can be helpful for a user to see if the PRF and time dependent models are being calculated correctly. False fit_va bool Whether or not to fit Velocity Aberration (which implicitly will try to fit other kinds of time variability). This will try to fit the \"long term\" trends in the dataset. If True, this will take slightly longer to fit. If you are interested in short term phenomena, like transits, you may find you do not need this to be set to True. If you have the time, it is recommended to run it. True iter_negative bool When fitting light curves, it isn't possible to force the flux to be positive. As such, when we find there are light curves that deviate into negative flux values, we can clip these targets out of the analysis and rerun the model. If iter_negative is True, PSFmachine will run up to 3 times, clipping out any negative targets each round. True load_shape_model bool Load PRF shape model from disk or not. Default models were computed from FFI of the same channel and quarter. False shape_model_file string Path to PRF model file to be passed to load_shape_model(input) . If None, then precomputed models will be download from Zenodo repo. None sap boolean Compute or not Simple Aperture Photometry. See Machine.compute_aperture_photometry() for details. True","title":"fit_lightcurves()"},{"location":"tpf/#psfmachine.tpf.TPFMachine.from_TPFs","text":"Convert TPF input into Machine object: Parse TPFs to extract time, flux, clux erros, and bookkeeping of the TPF-pixel correspondance Convert pixel-based coordinates (row, column) into WCS (ra, dec) for all pixels Clean pixels with no values, bad cadences, and remove duplicated pixels due to overlapping TPFs Query Gaia DR2 data base to find all sources present in the TPF images Clean unresolve sources (within 6`` = 1.5 pixels) and sources off silicon with a 1 pixel tolerance (distance from source gaia pocition and TPF edge) Parameters: Name Type Description Default tpfs lightkurve TargetPixelFileCollection Collection of Target Pixel files required magnitude_limit float Limiting magnitude to query Gaia catalog. 18 dr int Gaia data release to be use, default is 2, options are DR2 and EDR3 2 time_mask boolean array Mask to be applied to discard cadences if needed. None apply_focus_mask boolean Mask or not cadances near observation gaps to remove focus change. True query_ra numpy.array Array of RA to query Gaia catalog. Default is None and will use the coordinate centers of each TPF. None query_dec numpy.array Array of Dec to query Gaia catalog. Default is None and will use the coordinate centers of each TPF. None query_rad numpy.array Array of radius to query Gaia catalog. Default is None and will use the coordinate centers of each TPF. None **kwargs None Keyword arguments to be passed to TPFMachine . {} Returns: Type Description Machine object A Machine class object built from TPFs.","title":"from_TPFs()"},{"location":"tpf/#psfmachine.tpf.TPFMachine.lcs_in_tpf","text":"Returns the light curves from a given TPF as a lightkurve.LightCurveCollection. Parameters: Name Type Description Default tpf_number int Index of the TPF required","title":"lcs_in_tpf()"},{"location":"tpf/#psfmachine.tpf.TPFMachine.load_shape_model","text":"Loads a PRF shape model from a FITs file. Not implemented: By default this function will load PRF shapes computed from FFI data (Kepler, K2, or TESS). Parameters: Name Type Description Default input string Name of the file containing the shape parameters and weights. The file has to be FITS format. If None, then previously computed shape model from Kepler's FFI will be download from https://zenodo.org/record/5504503/ and used as default. The file download from Zenodo happens only the first time that shape models of a given mission (e.g. Kepler, K2) are asked. Then, shape models for all channels and quarters will be locally available for future use. The file is stored in psfmachine/src/psfmachine/data/ . None plot boolean Plot or not the mean model. False","title":"load_shape_model()"},{"location":"tpf/#psfmachine.tpf.TPFMachine.plot_tpf","text":"Make a diagnostic plot of a given TPF in the stack If you passed a stack of TPFs, this function will show an image of that TPF, and all the light curves inside it, alongside a diagnostic of which source the light curve belongs to. Parameters: Name Type Description Default tdx int Index of the TPF to plot required sap boolean Overplot the pixel mask used for aperture photometry. True","title":"plot_tpf()"},{"location":"tpf/#psfmachine.tpf.TPFMachine.save_shape_model","text":"Saves the weights of a PRF fit to disk as a FITS file. Parameters: Name Type Description Default output str, None Output file name. If None, one will be generated. None","title":"save_shape_model()"}]}